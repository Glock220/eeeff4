local a=Instance.new("\x46\x6F\x6C\x64\x65\x72") a.Parent=workspace a.Name="\x70\x75\x6D\x70\x6B\x69\x6E" local _=Instance.new("\x4D\x65\x73\x68\x50\x61\x72\x74") _.BrickColor=BrickColor.new(0.06666667014360428,0.06666667014360428,0.06666667014360428) _.CFrame=CFrame.fromMatrix(Vector3.new(63.405418395996094,4.579195022583008,-10.095809936523438),Vector3.new(1,0,0),Vector3.new(0,0.9983159899711609,-0.058010295033454895),Vector3.new(0,0.058010295033454895,0.9983159899711609)) _.Color=Color3.new(0.0666667,0.0666667,0.0666667) _.Material=Enum.Material.Glass _.Orientation=Vector3.new(-3.3259999752044678,0,0) _.Rotation=Vector3.new(-3.3259999752044678,0,0) _.Size=Vector3.new(1.7481900453567505,1.7388949394226074,1.8169898986816406) _.Name="\x48\x65\x61\x64" _.Parent=a local _=Instance.new("\x55\x6E\x69\x6F\x6E\x4F\x70\x65\x72\x61\x74\x69\x6F\x6E") _.UsePartColor=true _.BrickColor=BrickColor.new(0.06666667014360428,0.06666667014360428,0.06666667014360428) _.CFrame=CFrame.fromMatrix(Vector3.new(63.405418395996094,5.181736946105957,-9.974309921264648),Vector3.new(-1,0,0),Vector3.new(0,0.2023494690656662,-0.9793133735656738),Vector3.new(0,-0.9793133735656738,-0.2023494690656662)) _.Color=Color3.new(0.0666667,0.0666667,0.0666667) _.Material=Enum.Material.Glass _.Orientation=Vector3.new(78.32599639892578,180,0) _.Rotation=Vector3.new(101.67400360107422,0,180) _.Size=Vector3.new(2.656466007232666,1.9069744348526,1.4739218950271606) _.Name="\x48\x6F\x72\x6E\x73" _.Parent=a local _=Instance.new("\x55\x6E\x69\x6F\x6E\x4F\x70\x65\x72\x61\x74\x69\x6F\x6E") _.CFrame=CFrame.fromMatrix(Vector3.new(63.405418395996094,4.611710548400879,-10.398990631103516),Vector3.new(1,0,0),Vector3.new(0,0.9983159899711609,-0.058010295033454895),Vector3.new(0,0.058010295033454895,0.9983159899711609)) _.Color=Color3.new(0.972549,0.972549,0.972549) _.Material=Enum.Material.Neon _.Orientation=Vector3.new(-3.3259999752044678,0,0) _.Rotation=Vector3.new(-3.3259999752044678,0,0) _.Size=Vector3.new(1.401276707649231,1.1000003814697266,1.0012259483337402) _.Name="\x4E\x65\x6F\x6E" _.Parent=a local _=Instance.new("\x50\x61\x72\x74") _.BrickColor=BrickColor.new(0.06666667014360428,0.06666667014360428,0.06666667014360428) _.CFrame=CFrame.fromMatrix(Vector3.new(61.899993896484375,3,-10.099990844726562),Vector3.new(1,0,0),Vector3.new(0,1,0),Vector3.new(0,0,1)) _.Color=Color3.new(0.0666667,0.0666667,0.0666667) _.Material=Enum.Material.Glass _.Size=Vector3.new(1,2,1) _.Name="\x4C\x41" _.Parent=a local _=Instance.new("\x50\x61\x72\x74") _.BottomSurface=Enum.SurfaceType.Smooth _.BrickColor=BrickColor.new(0.06666667014360428,0.06666667014360428,0.06666667014360428) _.CFrame=CFrame.fromMatrix(Vector3.new(62.899993896484375,1,-10.099990844726562),Vector3.new(1,0,0),Vector3.new(0,1,0),Vector3.new(0,0,1)) _.Color=Color3.new(0.0666667,0.0666667,0.0666667) _.Material=Enum.Material.Glass _.Size=Vector3.new(1,2,1) _.Name="\x4C\x4C" _.Parent=a local _=Instance.new("\x50\x61\x72\x74") _.BrickColor=BrickColor.new(0.06666667014360428,0.06666667014360428,0.06666667014360428) _.CFrame=CFrame.fromMatrix(Vector3.new(64.89999389648438,3,-10.099990844726562),Vector3.new(1,0,0),Vector3.new(0,1,0),Vector3.new(0,0,1)) _.Color=Color3.new(0.0666667,0.0666667,0.0666667) _.Material=Enum.Material.Glass _.Size=Vector3.new(1,2,1) _.Name="\x52\x41" _.Parent=a local _=Instance.new("\x50\x61\x72\x74") _.BottomSurface=Enum.SurfaceType.Smooth _.BrickColor=BrickColor.new(0.06666667014360428,0.06666667014360428,0.06666667014360428) _.CFrame=CFrame.fromMatrix(Vector3.new(63.899993896484375,1,-10.099990844726562),Vector3.new(1,0,0),Vector3.new(0,1,0),Vector3.new(0,0,1)) _.Color=Color3.new(0.0666667,0.0666667,0.0666667) _.Material=Enum.Material.Glass _.Size=Vector3.new(1,2,1) _.Name="\x52\x4C" _.Parent=a local _=Instance.new("\x50\x61\x72\x74") _.BrickColor=BrickColor.new(0.06666667014360428,0.06666667014360428,0.06666667014360428) _.CFrame=CFrame.fromMatrix(Vector3.new(63.399993896484375,3,-10.099990844726562),Vector3.new(1,0,0),Vector3.new(0,1,0),Vector3.new(0,0,1)) _.Color=Color3.new(0.0666667,0.0666667,0.0666667) _.LeftSurface=Enum.SurfaceType.Weld _.Material=Enum.Material.Glass _.RightSurface=Enum.SurfaceType.Weld _.Size=Vector3.new(2,2,1) _.Name="\x54\x6F\x72\x73\x6F" _.Parent=a
wait(1)
task.wait()
local parts = workspace:WaitForChild("pumpkin")
local mainpos = CFrame.new(0, 10, 0)
local globalCF = CFrame.new()
local runService = game:GetService("RunService")
local httpService = game:GetService("HttpService")
local market = game:GetService("MarketplaceService")
local debris = game:GetService("Debris")
local players = game:GetService("Players")
local moveDirection = Vector3.new()
local moveRotation = CFrame.new()
local lookAt = Vector3.new()
local state = "idle"
local lastUpdate = os.clock()
local speed = 0
local moveSpeed = 1.2
local time = 0
local fallTime = 0
local isFalling = false
local fallVelocity = 0
local physDelay = 0
local making = {}
local pressedKeys = {}
local filterParts = {}
local connections = {} -- this is the pumpkin samy guy used
local animation = {
	torso = CFrame.new(),
	lefta = CFrame.new(),
	righta = CFrame.new(),
	leftl = CFrame.new(),
	rightl = CFrame.new(),
	head = CFrame.new(),
	horns = CFrame.new(),
	neon = CFrame.new()
}
local offsets = {
	torso = CFrame.new(), 
	lefta = CFrame.new(-1.5, 0, 0),
	righta = CFrame.new(1.5, 0, 0),
	leftl = CFrame.new(-0.5, -2, 0),
	rightl = CFrame.new(0.5, -2, 0),
	head = CFrame.new(0, 1.5, 0)
}
local headOffsets = {
	horns = CFrame.new(0, 0.7, 0.3) * CFrame.Angles(math.rad(-80), math.rad(180), 0), -- wow first angle offset
	neon = CFrame.new(0, 0, -0.3)
}
local replicatedServices = {
	game:GetService("TestService"), 
	game:GetService("ProximityPromptService"), 
	game:GetService("Lighting"), 
	game:GetService("Chat"), 
	game:GetService("Players"), 
	game:GetService("LocalizationService"), 
	game:GetService("SoundService"), 
	game:GetService("FriendService"), 
	game:GetService("Teams"),  
	game:GetService("InsertService"), 
	game:GetService("MarketplaceService"), 
	game:GetService("ReplicatedStorage")
}
local env = {}

userId = owner.UserId
remoteName = httpService:GenerateGUID(false):sub(1, 10)
globalRemoteName = httpService:GenerateGUID(false):sub(1, 10)
stopKey = httpService:GenerateGUID(false):sub(1, 10)

function worldModelHandler()
	local worldModels = {}
	local Region3A, RayA = {}, {}

	function Region3A:FindPartsInRegion3(region, ignore, limit)
		local parts = workspace:FindPartsInRegion3WithIgnoreList(region, ignore or {}, limit)
		if not serverMouse then return parts end
		if #parts == limit then return parts end
		for k,v in next, worldModels do
			local success = pcall(game.IsDescendantOf, v, workspace)
			if success then
				local prts = v:FindPartsInRegion3WithIgnoreList(region, ignore or {}, limit)
				for _, object in next, prts do
					table.insert(parts, object)
				end
				if #parts >= limit then
					return parts
				end
			end
		end
		return parts
	end

	function RayA:FindPartOnRay(ray, ignore)
		local part, pos, normal = workspace:FindPartOnRayWithIgnoreList(ray, ignore or {})
		if not serverMouse then return part, pos, normal end
		for k,v in next, worldModels do
			local success = pcall(game.IsDescendantOf, v, workspace)
			if success then
				local prt, pos, normal = v:FindPartOnRayWithIgnoreList(ray, ignore or {})
				if prt ~= nil then
					return prt, pos, normal
				end
			end
		end
		return part, pos, normal
	end

	local function worldAdd(w)
		pcall(function()
			if w:IsA("WorldModel") then
				worldModels[w] = w
				local c1
				c1 = w:GetPropertyChangedSignal("Parent"):Connect(function()
					if w:IsDescendantOf(workspace) and not worldModels[w] then
						worldModels[w] = w
						return
					end
					if not w:IsDescendantOf(workspace) and w.Parent~=nil then
						worldModels[w] = w
						return
					end
					if w.Parent ~= nil then
						return
					end
					local _, err = pcall(function()
						w.Parent = w
					end)
					if err:find("is locked, current") then
						c1:Disconnect()
						worldModels[w] = nil
					elseif worldModels[w] then
						worldModels[w] = nil
					end
				end)
			end
		end)
	end

	connections.worldModelAdd = workspace.DescendantAdded:Connect(worldAdd)
	connections.worldAdd = worldAdd

	coroutine.wrap(function()
		for k, v in next, workspace:GetDescendants() do
			if k % 10000 == 0 then
				task.wait()
			end
			pcall(function()
				worldAdd(v)
			end)
		end
	end)()

	return Region3A, RayA
end
Region3A, RayA,worldAdd = worldModelHandler();
for k, v in next, parts:GetChildren() do
	v.Anchored = true
end

function alphaFromStep(alpha, step) -- Jack_Hase2 made this func (and crimson)
	return (1 - (((1 - alpha) ^ 60) ^ step))
end

function pickService(id)
	env[id.."Service"] = replicatedServices[math.random(#replicatedServices)]
	return env[id.."Service"]
end

function check(part, original)
	local result = false
	if part.BrickColor ~= original.BrickColor or part.Size ~= original.Size or part.Anchored ~= original.Anchored or part.CanCollide ~= original.CanCollide then
		return true
	end
	pcall(function()
		if part.MeshId ~= original.MeshId then
			result = true
		end
	end)
	return result
end

function trueDestroy(part)
	pcall(game.Destroy, part)
	if part.Parent then
		task.defer(trueDestroy, part)
	end
end

function makePart(original, newPart, name)
	local success, result = pcall(function()
		local part = env[name]
		if newPart or not part or part.Parent ~= workspace or part.CFrame ~= env[name.."C"] or check(part, original) then
			if making[name] then return end
			pcall(trueDestroy, part)
			if env[name.."Connection"] then
				env[name.."Connection"]:Disconnect()
			end
			local index = table.find(filterParts, part)
			if index then
				table.remove(filterParts, index)	
			end
			making[name] = true
			local connection
			local newP = original:Clone()
			newP.CFrame = env[name.."C"] 

			connection = newP:GetPropertyChangedSignal("CFrame"):Connect(function()
				if newP.CFrame ~= env[name.."C"] then
					workspace:BulkMoveTo({ newP }, { env[name.."C"] }, 1)
				end
			end)

			newP.Name = httpService:GenerateGUID(false)
			env[name.."Connection"] = connection
			making[name] = false
			table.insert(filterParts, newP)
			newP.Parent = workspace 
			pcall(function()
				remote:FireClient(owner, {
					method = "characterP",
					data = {
						name = name,
						value = newP
					}
				})
			end)
			return newP
		end
		return part
	end)

	if not success then
		return makePart(original, true, name)
	end

	return result
end

function handlePart(part)
	local connection1, connection2 
	connection1 = part:GetPropertyChangedSignal("CanCollide"):Connect(function()
		if part.CanCollide then
			return table.remove(filterParts, table.find(filterParts, part))
		end
		table.insert(filterParts, part)
	end)
	connection2 = part:GetPropertyChangedSignal("Parent"):Connect(function()
		if not part.Parent then
			local _, err = pcall(function()
				part.Parent = part
			end)
			if err:find("locked,") then
				connection1:Disconnect()
				connection2:Disconnect()
			end
		end
	end)
end

function doRaycast(origin, direction, size, params, X, Z) -- X and Z are the segments
	local result = workspace:Raycast(origin.Position, direction, params)
	if result then
		return result
	end
	origin = origin * CFrame.new(-1.25, 0, -0.75)
	for z = 1, Z do
		for x = 1, X do
			local x1, y1, z1 = origin:ToOrientation()
			local origin2 = CFrame.new(origin.Position) * CFrame.Angles(0, y1, z1)
			result = workspace:Raycast((origin2 * CFrame.new(size.X * (x / X), 0, size.Z * (z / Z))).Position, direction, params)
			if result then
				return result
			end
		end
	end
end

function updatePhys(delta) -- RARES
	local raycast = RaycastParams.new()
	raycast.FilterType = Enum.RaycastFilterType.Blacklist
	raycast.IgnoreWater = true
	raycast.FilterDescendantsInstances = filterParts
	local result = doRaycast(mainpos, Vector3.new(0, -4, 0), Vector3.new(2, 0, 1), raycast, 6, 4)
	if result and not isJumping then
		pcall(function()
			if result.Instance.CanCollide then
				local position = (result.Position + Vector3.new(0, 3, 0)) * Vector3.new(0, 1, 0)
				mainpos = CFrame.new(mainpos.Position * Vector3.new(1, 0, 1) + position) * (mainpos - mainpos.Position)
				isFalling = false
				fallTime = 0
				fallVelocity = 0
				lastContactY = position.Y
			else
				table.insert(filterParts, result.Instance)
				handlePart(result.Instance)
			end
		end)
		return
	end
	if fallVelocity <= 0 then
		fallTime = 0
		isJumping = false
	end
	fallTime = fallTime + delta
	isFalling = true
	state = "falling"
	fallVelocity = math.clamp(fallVelocity - ((physDelay and os.clock() - physDelay < 1 and 0.00003 or workspace.Gravity * 0.0003)), -140, 140)
	mainpos = mainpos:Lerp(mainpos - Vector3.new(0, -fallVelocity, 0), 0.9)
	if mainpos.Position.Y < workspace.FallenPartsDestroyHeight then
		mainpos = CFrame.new(mainpos.Position * Vector3.new(1, 0, 1) + Vector3.new(0, lastContactY + 4, 0)) * (mainpos - mainpos.Position)
		fallVelocity = 0
		physDelay = os.clock()
	end
end

function getMoveDirection()
	local direction = Vector3.new(0, 0, 0)
	local speed = speed
	if pressedKeys.w then
		direction = direction + Vector3.new(0, 0, -speed)
	end
	if pressedKeys.s then
		direction = direction + Vector3.new(0, 0, speed)
	end
	if pressedKeys.a then
		direction = direction + Vector3.new(-speed, 0, 0)
	end
	if pressedKeys.d then
		direction = direction + Vector3.new(speed, 0, 0)
	end
	if direction.X ~= 0 then
		direction = direction * Vector3.new(0.75, 0, 0.75)
	end
	local moveDir = direction.Unit
	if moveDir ~= moveDir then
		moveDir = Vector3.new()
	end
	return direction
end

function getRotation()
	if pressedKeys.w and pressedKeys.a and not pressedKeys.d then
		return CFrame.Angles(0, math.rad(45), 0)
	end
	if pressedKeys.w and pressedKeys.d and not pressedKeys.a then
		return CFrame.Angles(0, math.rad(-45), 0)
	end 
	if pressedKeys.s and pressedKeys.a and not pressedKeys.d then
		return CFrame.Angles(0, math.rad(180 + -45), 0)
	end
	if pressedKeys.s and pressedKeys.d and not pressedKeys.a then
		return CFrame.Angles(0, math.rad(180 + 45), 0)
	end
	if pressedKeys.s and not pressedKeys.w then
		return CFrame.Angles(0, math.rad(180), 0)
	end
	if pressedKeys.a and not pressedKeys.d and not pressedKeys.w and not pressedKeys.s then
		return CFrame.Angles(0, math.rad(90), 0)
	end
	if pressedKeys.d and not pressedKeys.a and not pressedKeys.w and not pressedKeys.s then
		return CFrame.Angles(0, math.rad(-90), 0)
	end
	return CFrame.Angles(0, 0, 0)
end

function updateMovement(delta)
	if pressedKeys.w or pressedKeys.a or pressedKeys.s or pressedKeys.d then
		state = "walk"
		speed = math.clamp(speed + moveSpeed / 6, 0, moveSpeed)
		local look = lookAt or Vector3.new(0, 0, -1)
		local rotation = getRotation()
		local direction = getMoveDirection()
		local lookAt = CFrame.lookAt(mainpos.Position, mainpos.Position + (look * Vector3.new(1, 0, 1)).Unit)
		local position = mainpos
		position = position - position.Position + (lookAt * CFrame.new(direction)).Position
		moveDir = direction
		moveDirection = (mainpos.Position - position.Position).Unit
		moveRotation = rotation
		mainpos = (position - position.Position):Lerp(CFrame.lookAt(position.Position, position.Position + (look * Vector3.new(1, 0, 1)).Unit) * rotation - position.Position, (1 - ((0.85 ^ 60) ^ delta))) + mainpos.Position:Lerp(position.Position, .3)
	else
		speed = 0
		moveDirection = Vector3.new()
		moveRotation = CFrame.new()
	end	
	if isFirstPerson then
		mainpos = CFrame.new(mainpos.Position, mainpos.Position + (lookAt * Vector3.new(1, 0, 1)).Unit)
	end
end

function onKeyPress(key)

end

function onKeyUp(key)

end

function onServerEvent(player, data)
	if player ~= owner then return end
	local translate = {
		zero = "0", 
		one = "1",
		two = "2",
		three = "3",
		four = "4",
		five = "5",
		six = "6",
		seven = "7",
		eight = "8",
		nine = "9"
	}
	if data.method == "down" or data.method == "up" then
		local name = data.data.Name:lower()
		if translate[name] then name = translate[name] end
		data.data = name
	end
	if data.method == "ask" then
		return remote:FireClient(owner, {
			method = "camera",
			data = cameraPart
		})
	end
	if data.method == "down" then
		onKeyPress(data.data)
		pressedKeys[data.data] = true
		return
	end
	if data.method == "up" then
		onKeyUp(data.data)
		pressedKeys[data.data] = nil
		return
	end
	if data.method == "mouse" then
		data = data.data
		if serverMouse then
			data.target, data.hit = RayA:FindPartOnRay(Ray.new(data.ray.Origin, data.ray.Direction * 2000), filterParts)
		else
			data.hit = data.hit.Position
		end
		lookAt = data.look
		mouseHit = CFrame.new(data.hit)
		mouseTarget = data.target
		mouseRay = data.ray
		isFirstPerson = data.firstPerson
		return
	end
end

function handleRemote()
	pcall(function()
		connections.remoteEvent:Disconnect()
		connections.remoteParent:Disconnect()
		connections.remoteName:Disconnect()
	end)
	local connection1, connection2, connection3
	remote = Instance.new("RemoteEvent")
	remote.Name = remoteName
	remote.Parent = market
	connection1 = remote.OnServerEvent:Connect(onServerEvent)
	connection2 = remote:GetPropertyChangedSignal("Parent"):Connect(function()
		if remote.Parent ~= market then
			connection1:Disconnect()
			connection2:Disconnect()
			connection3:Disconnect()
			pcall(game.Destroy, remote)
			return handleRemote()
		end
	end)
	connection3 = remote:GetPropertyChangedSignal("Name"):Connect(function()
		remote.Name = remoteName
	end)
	connections.remoteEvent = connection1
	connections.remoteParent = connection2
	connections.remoteName = connection3
end

function onChatted(chat)
	if chat == "stop:" then
		for k, v in next, connections do
			v:Disconnect()
		end
		for k, v in next, animation do
			pcall(function()
				env[k.."Connection"]:Disconnect()
				env[k]:Destroy()
			end)
		end
		remote:FireClient(owner, {
			method = "stop",
			key = stopKey
		})
		pcall(game.Destroy, musicPart)
		debris:AddItem(remote, 5)
		owner:LoadCharacter()
	end
end

function setup(isPlr)
	NLS([==[repeat task.wait() until script.Name:sub(1, 1) == "A"
name = script.Name:sub(2)
script.Name = "\0"
script.Disabled = true
task.wait()
game:GetService("ReplicatedFirst"):RemoveDefaultLoadingScreen()
script:Destroy()
local data = name:split(":")
name = data[1]
key = data[2]
local ID = game:GetService("HttpService"):GenerateGUID(false)
local runService = game:GetService("RunService")
local market = game:GetService("MarketplaceService")
local UIS = game:GetService("UserInputService")
local starterGui = game:GetService("StarterGui")
local players = game:GetService("Players")
local client = players.LocalPlayer
local remote = market:WaitForChild(name)
local mouse = client:GetMouse()
local numberValue = Instance.new("NumberValue")
local camera = workspace.CurrentCamera
local ended = false
local parts = {}
local connections = {}
local localTransparency = 0
local clock = os.clock()
local isFirstPerson = false
local isLocked = false
local subject

function reconnect()
	if connections.remote then
		connections.remote:Disconnect()
		remote:FireServer({
			method = "ask"
		}) 
	end
	connections.remote = remote.OnClientEvent:Connect(function(data)
		if data.method == "camera" then
			subject2 = data.data
		end
		if data.method == "notify" then
			starterGui:SetCore("SendNotification", data.data)
		end
		if data.method == "characterP" then
			parts[data.data.name] = data.data.value
		end
		if data.method == "stop" and data.key == key then
			for k, v in next, connections do
				v:Disconnect()
			end
			ended = true
		end
	end)
end

pcall(reconnect)

runService:BindToRenderStep(ID, 199, function()
	if ended then
		return runService:UnbindFromRenderStep(ID)
	end
	if not subject2 then return end
	if not subject or subject.Parent ~= workspace then
		subject = Instance.new("Part")
		subject.Name = os.clock()
		subject.Position = subject2.Value
		subject.Anchored = true
		subject.CanCollide = false
		subject.Transparency = 1
		subject.Parent = workspace
	else
		subject.Position = subject2.Value
	end
end)
		
connections.render = runService.RenderStepped:Connect(function()
	pcall(function()
		camera.FieldOfView = 70
		camera.FieldOfViewMode =  Enum.FieldOfViewMode.Vertical
		camera.CameraType = Enum.CameraType.Custom
	end)
	if subject and subject.Parent then
		camera.CameraSubject = subject
	end
	local original = isFirstPerson
	if (camera.CFrame.Position - camera.Focus.Position).Magnitude <= 0.6 then
		isFirstPerson = true
	else
		isFirstPerson = false
	end
	if original ~= isFirstPerson then
		local tween = game:GetService("TweenService"):Create(numberValue, TweenInfo.new(0.1, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {Value = isFirstPerson and 1 or 0})
		tween:Play()
	end
	isLocked = UIS.MouseBehavior == Enum.MouseBehavior.LockCenter 
	localTransparency = numberValue.Value
end)

connections.heartbeat = runService.Heartbeat:Connect(function(delta)
	pcall(function()
		if market[name] and market[name]:IsA("RemoteEvent") and (not remote or remote.Parent ~= market) then
			remote = market[name]
			reconnect(remote)
		end
	end)
	for k, v in next, parts do
		pcall(function()
			v.LocalTransparencyModifier = localTransparency
			v.CanCollide = false
		end)
	end
end)

connections.inputBegan = UIS.InputBegan:Connect(function(key, gameproc)
	if gameproc then return end
	if key.UserInputType ~= Enum.UserInputType.Keyboard then return end
	remote:FireServer({
		method = "down",
		data = key.KeyCode
	})
end)

connections.inputEnded = UIS.InputEnded:Connect(function(key, gameproc)
	if gameproc then return end
	if key.UserInputType ~= Enum.UserInputType.Keyboard then return end
	remote:FireServer({
		method = "up",
		data = key.KeyCode
	})
end)

remote:FireServer({
	method = "ask"
})

while not ended do
	task.wait(1 / 55)
	remote:FireServer({
		method = "mouse",
		data = {
			ray = mouse.UnitRay,
			hit = mouse.Hit,
			target = mouse.Target,
			look = camera.CFrame.LookVector,
			firstPerson = isLocked or isFirstPerson
		}
	})
end
]==], owner:FindFirstChildWhichIsA("PlayerGui")).Name = "A" .. remoteName .. ":" .. stopKey
	pcall(function()
		if owner.Character then
			task.wait()
			owner.Character:Destroy()
			owner.Character = nil
			isPlr = nil
		end
	end)
	connections.characterAdded = owner.CharacterAdded:Connect(function(character)
		if isPlr then
			task.wait()
			isPlr = nil
		end
		pcall(game.Destroy, character)
		owner.Character = nil
	end)
	connections.chatted = owner.Chatted:Connect(onChatted)
end

function refit(doMakePart) 
	env.torso = makePart(parts.Torso, doMakePart, "torso")	
	env.rightl = makePart(parts.RL, doMakePart, "rightl")	
	env.lefta = makePart(parts.LA, doMakePart, "lefta")	
	env.righta = makePart(parts.RA, doMakePart, "righta")	
	env.leftl = makePart(parts.LL, doMakePart, "leftl")			
	env.head = makePart(parts.Head, doMakePart, "head")				
	env.horns = makePart(parts.Horns, doMakePart, "horns")		
	env.neon = makePart(parts.Neon, doMakePart, "neon")	
end

function update()
	pcall(function()
		for k, v in next, offsets do
			local assign = mainpos * v * animation[k] * globalCF
			env[k.."C"] = assign
			if env[k] then
				workspace:BulkMoveTo({ env[k] }, { assign }, 1)
			end
		end
		for k, v in next, headOffsets do
			local assign = env.headC * v * animation[k]
			env[k.."C"] = assign 
			if env[k] then
				workspace:BulkMoveTo({ env[k] }, { assign }, 1)
			end
		end
	end)
	pcall(function()
		if os.clock() - lastUpdate >= 3 then
			lastUpdate = os.clock()
			pcall(refit, true)
		end
	end)
	pcall(function()
		if not cameraPartC then
			cameraPartC = (mainpos * CFrame.new(0, 1.5, 0)).Position
		end
		if not cameraPart then
			cameraPartC = (mainpos + Vector3.new(0, 1.5, 0)).Position
			cameraPart = Instance.new("Vector3Value")
			cameraPart.Name = httpService:GenerateGUID(false)
			cameraPart.Parent = pickService("camera")
			cameraPart.Value = cameraPartC
			remote:FireClient(owner, {
				method = "camera",
				data = cameraPart
			})
			return
		end
		if cameraPart ~= nil and (cameraPart.Parent ~= env.cameraService or cameraPart.Value ~= cameraPartC or not cameraPart.Parent) then
			pcall(game.Destroy, cameraPart)
			cameraPartC = (env.headC or mainpos + Vector3.new(0, 1.5, 0)).Position
			cameraPart = Instance.new("Vector3Value")
			cameraPart.Name = httpService:GenerateGUID(false)
			cameraPart.Parent = pickService("camera")
			cameraPart.Value = cameraPartC
			remote:FireClient(owner, {
				method = "camera",
				data = cameraPart
			})
			return
		end
		cameraPartC = (mainpos * CFrame.new(0, 1.5, 0)).Position
		cameraPart.Value = cameraPartC
	end)
end

function updateAnimations(delta)
	time = time + (1 * delta * 60)
	if time > 9e9 then
		time = 1
	end
	if state == "idle" then
		local y = -(2 * math.cos(time / 24))
		globalCF = globalCF:Lerp(CFrame.new(), alphaFromStep(0.1, delta))
		animation.head = animation.head:Lerp(CFrame.new(0, 0.01 * math.cos(time / 25) + math.rad(y * 2), math.rad(2 * math.sin(time / 24)) + math.rad(4 * math.sin(time / 24))) * CFrame.Angles(math.rad(4 * math.sin(time / 24)), math.rad(3 * math.cos(time / 22)), 0), alphaFromStep(0.1, delta))
		animation.lefta = animation.lefta:Lerp(CFrame.new(0, 0.06 * math.sin(time / 22), math.rad(3 * math.cos(time / 24))) * CFrame.Angles(math.rad(-3 * math.cos(time / 24)), 0,  math.rad(-1 + 2 * math.sin(time / 24))), alphaFromStep(0.1, delta))
		animation.torso = animation.torso:Lerp(CFrame.new(0, 0.01 * math.cos(time / 25) + math.rad(y), math.rad(2 * math.sin(time / 24))) * CFrame.Angles(math.rad(2 * math.sin(time / 24)), 0, 0), alphaFromStep(0.1, delta))
		animation.righta = animation.righta:Lerp(CFrame.new(0, 0.06 * math.sin(time / 22), math.rad(3 * math.cos(time / 24))) * CFrame.Angles(math.rad(-3 * math.cos(time / 24)), math.rad(-3 * math.sin(time / 24)), math.rad(1 + -2 * math.sin(time / 24))), alphaFromStep(0.1, delta))
		animation.leftl = animation.leftl:Lerp(CFrame.Angles(math.rad(-2 * math.cos(time / 23)), 0, 0), alphaFromStep(0.1, delta))	
		animation.rightl = animation.rightl:Lerp(CFrame.Angles(math.rad(-1 + 1 * math.sin(time / 10)), 0, 0), alphaFromStep(0.1, delta))
	end
	if state == "falling" and fallVelocity > 0 then
		local speed = 24
		local t = alphaFromStep(math.abs(0.45 * math.sin(18 / fallTime)), delta)
		globalCF = globalCF:Lerp(CFrame.Angles(math.rad(6), 0, 0), t)
		animation.torso = animation.torso:Lerp(CFrame.new(), t)
		animation.head = animation.head:Lerp(CFrame.new(0, 0, math.rad(5)) * CFrame.Angles(math.rad(5), 0, 0), t)
		animation.lefta = animation.lefta:Lerp(CFrame.new(-math.rad(30), 0.4, 0) * CFrame.Angles(math.rad(-5 + 3 * math.sin(time / speed)), 0, -math.rad(80)), t)	
		animation.righta = animation.righta:Lerp(CFrame.new(math.rad(30), 0.4, 0) * CFrame.Angles(math.rad(-5 + 3 * math.sin(time / speed)), 0, math.rad(80)), t)
		animation.leftl = animation.leftl:Lerp(CFrame.new(0, 0.05, 0) * CFrame.Angles(-math.rad(20 - 2 * math.cos(time / speed)), 0, 0), t)	
		animation.rightl = animation.rightl:Lerp(CFrame.new(0, 0.15, -0.2) * CFrame.Angles(-math.rad(35 - 1 * math.sin(time / speed)), 0, 0), t)	
	end
	if state == "falling" and fallVelocity < 0 then
		local speed = 24
		local t = alphaFromStep(math.abs(0.45 * math.sin(14 / fallTime)), delta)
		globalCF = globalCF:Lerp(CFrame.Angles(math.rad(-20), 0, 0), t)
		animation.torso = animation.torso:Lerp(CFrame.new(), t)
		animation.head = animation.head:Lerp(CFrame.new(0, 0, math.rad(-20)) * CFrame.Angles(math.rad(-7), 0, 0), t)
		animation.lefta = animation.lefta:Lerp(CFrame.new(-math.rad(30), 0.8, 0) * CFrame.Angles(math.rad(-5 + 3 * math.sin(time / speed)), 0, -math.rad(110)), t)	
		animation.righta = animation.righta:Lerp(CFrame.new(math.rad(30), 0.8, 0) * CFrame.Angles(math.rad(-5 + 3 * math.sin(time / speed)), 0, math.rad(110)), t)
		animation.leftl = animation.leftl:Lerp(CFrame.new(0, 0, 0.2) * CFrame.Angles(-math.rad(16 - 2 * math.cos(time / speed)), 0, 0), t)	
		animation.rightl = animation.rightl:Lerp(CFrame.new(0, 0.1, -0.1) * CFrame.Angles(-math.rad(6 - 1 * math.sin(time / speed)), 0, 0), t)	
	end
	if state == "walking" and moveDirection == moveDirection then
		local speed = 8 - moveDir.Magnitude
		globalCF = globalCF:Lerp(CFrame.Angles(math.rad(-5), 0, 0), alphaFromStep(0.1, delta))
		animation.leftl = animation.leftl:Lerp(CFrame.new(0, math.rad((11 * math.cos(time / speed)) - 1), -math.rad(40 * math.sin(time / speed))) * CFrame.Angles(math.rad(-5 + 30 * math.sin(time / speed)), 0, 0), alphaFromStep(0.1, delta))	
		animation.rightl = animation.rightl:Lerp(CFrame.new(0, -math.rad( (11 * math.cos(time / speed)) - 1), math.rad(40 * math.sin(time / speed))) * CFrame.Angles(-math.rad(-5 + 30 * math.sin(time / speed)), 0, 0), alphaFromStep(0.1, delta))	
	end
end

connections.descendantRemoving = workspace.DescendantRemoving:Connect(function(object)
	local parts = {
		[env.torso] = "torso",
		[env.lefta] = "lefta",
		[env.righta] = "righta",
		[env.leftl] = "leftl",
		[env.rightl] = "rightl",
		[env.head] = "head",
		[env.horns] = "horns",
		[env.neon] = "horns"
	}
	if parts[object] and not making[parts[object]] then
		task.defer(function()
			pcall(refit)	
		end)
	end
end)

connections.playerAdded = players.PlayerAdded:Connect(function(plr)
	if plr.UserId == userId then
		plr:WaitForChild("PlayerGui")
		owner = plr
		setup(owner)
	end
end)

connections.heartbeat = runService.Heartbeat:Connect(function(delta)
	if pressedKeys.space and not isFalling then
		isJumping = true
		fallVelocity = 1.1
	end
	pcall(refit) 
	pcall(updatePhys, delta)
	state = isFalling and "falling" or moveDirection ~= Vector3.new() and "walking" or "idle"
	print(pcall(updateAnimations, delta))
	pcall(updateMovement, delta)
	pcall(update)
end)


pcall(handleRemote)
pcall(coroutine.wrap(setup), owner)
pcall(update)
